{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "card-overlap-scroll",
  "type": "registry:component",
  "description": "basically a card but it",
  "files": [
    {
      "path": "labs-registry/components-v1/card-overlap-scroll.tsx",
      "content": "\"use client\";\n\nimport { useRef, useState, useEffect, useMemo, useCallback } from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport {\n  Card,\n  CardHeader,\n  CardTitle,\n  CardDescription,\n} from \"@/components/ui/card\";\nimport { useScroll } from \"@/labs-registry/components-v1/functions/hooks/use-scroll\";\nimport {\n  clamp,\n  mapRange,\n} from \"@/labs-registry/components-v1/functions/lib/maths\";\n\nexport interface OverlapCard {\n  title?: string;\n  description: string | React.ReactNode;\n  number?: number;\n}\n\nexport interface OverlapCardsProps {\n  cards: OverlapCard[];\n  className?: string;\n  // Header customization\n  header?: {\n    title: string;\n    subtitle: string;\n  };\n  // Scroll behavior\n  desktopScroll?: Partial<ScrollBehavior>;\n  mobileScroll?: Partial<ScrollBehavior>;\n  // Visual effects\n  parallaxRatio?: number;\n  showBackground?: boolean;\n  backgroundPattern?: \"grid\" | \"dots\" | \"none\";\n  // Card appearance\n  desktopCardDimensions?: Partial<CardDimensions>;\n  mobileCardDimensions?: Partial<CardDimensions>;\n  transitionDuration?: number;\n  cardClassName?: string;\n  cardStyle?: \"default\" | \"lenis\";\n  // Container styling\n  containerClassName?: string;\n}\n\nexport interface CardDimensions {\n  width: number;\n  height: number;\n}\n\nexport interface ScrollBehavior {\n  scrollPerCard: number;\n  baseScroll: number;\n  endScroll: number;\n}\n\nexport function OverlapCards({\n  cards,\n  className,\n  header,\n  desktopScroll = {},\n  mobileScroll = {},\n  parallaxRatio = 0.1,\n  showBackground = true,\n  backgroundPattern = \"grid\",\n  desktopCardDimensions = {},\n  mobileCardDimensions = {},\n  transitionDuration = 1000,\n  cardClassName,\n  cardStyle = \"lenis\",\n  containerClassName,\n}: OverlapCardsProps) {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const cardsContainerRef = useRef<HTMLDivElement>(null);\n  const backgroundRef = useRef<HTMLDivElement>(null);\n  const [rect, setRect] = useState({ top: 0, height: 0 });\n  const [current, setCurrent] = useState(0);\n  const [backgroundHeight, setBackgroundHeight] = useState(\"200vh\");\n  const [scrollHeight, setScrollHeight] = useState(\"100vh\");\n  const [endScrollVh, setEndScrollVh] = useState(0);\n\n  // Validate parallax ratio (between 0 and 1)\n  const validatedParallaxRatio = Math.max(0, Math.min(1, parallaxRatio));\n\n  // Default values for scroll behavior\n  const defaultDesktopScroll: ScrollBehavior = {\n    scrollPerCard: 60,\n    baseScroll: 80,\n    endScroll: 100,\n  };\n  const defaultMobileScroll: ScrollBehavior = {\n    scrollPerCard: 120,\n    baseScroll: 200,\n    endScroll: 150,\n  };\n\n  // Default values for card dimensions\n  const defaultDesktopDimensions: CardDimensions = { width: 480, height: 320 };\n  const defaultMobileDimensions: CardDimensions = { width: 280, height: 200 };\n\n  // Validation helpers\n  const validateScrollBehavior = useCallback(\n    (\n      config: Partial<ScrollBehavior>,\n      defaults: ScrollBehavior,\n    ): ScrollBehavior => {\n      return {\n        scrollPerCard: Math.max(\n          10,\n          config.scrollPerCard ?? defaults.scrollPerCard,\n        ),\n        baseScroll: Math.max(0, config.baseScroll ?? defaults.baseScroll),\n        endScroll: Math.max(0, config.endScroll ?? defaults.endScroll),\n      };\n    },\n    [],\n  );\n\n  const validateDimensions = useCallback(\n    (\n      dimensions: Partial<CardDimensions>,\n      defaults: CardDimensions,\n      isDesktop: boolean,\n    ): CardDimensions => {\n      const minWidth = isDesktop ? 200 : 150;\n      const minHeight = isDesktop ? 150 : 100;\n      const maxWidth = isDesktop\n        ? typeof window !== \"undefined\"\n          ? window.innerWidth * 0.8\n          : 800\n        : 400;\n      const maxHeight = isDesktop\n        ? typeof window !== \"undefined\"\n          ? window.innerHeight * 0.6\n          : 600\n        : 300;\n\n      return {\n        width: Math.min(\n          maxWidth,\n          Math.max(minWidth, dimensions.width ?? defaults.width),\n        ),\n        height: Math.min(\n          maxHeight,\n          Math.max(minHeight, dimensions.height ?? defaults.height),\n        ),\n      };\n    },\n    [],\n  );\n\n  const desktopScrollConfig = useMemo(\n    () => validateScrollBehavior(desktopScroll, defaultDesktopScroll),\n    [desktopScroll, validateScrollBehavior],\n  );\n  const mobileScrollConfig = useMemo(\n    () => validateScrollBehavior(mobileScroll, defaultMobileScroll),\n    [mobileScroll, validateScrollBehavior],\n  );\n  const desktopDimensions = useMemo(\n    () =>\n      validateDimensions(desktopCardDimensions, defaultDesktopDimensions, true),\n    [desktopCardDimensions, validateDimensions],\n  );\n  const mobileDimensions = useMemo(\n    () =>\n      validateDimensions(mobileCardDimensions, defaultMobileDimensions, false),\n    [mobileCardDimensions, validateDimensions],\n  );\n\n  // Get background pattern classes\n  const getBackgroundPattern = () => {\n    if (!showBackground || backgroundPattern === \"none\") return \"\";\n    if (backgroundPattern === \"dots\") {\n      return \"bg-[radial-gradient(#80808033_1px,transparent_1px)] bg-size-[20px_20px]\";\n    }\n    return \"bg-[linear-gradient(to_right,#80808033_1px,transparent_1px),linear-gradient(to_bottom,#80808033_1px,transparent_1px)] bg-size-[70px_70px]\";\n  };\n\n  // Calculate scroll height based on cards count and device\n  useEffect(() => {\n    const calculateScrollHeight = () => {\n      const isDesktop = window.innerWidth >= 768;\n      // Use custom scroll values or defaults\n      const scrollPerCard = isDesktop\n        ? desktopScrollConfig.scrollPerCard\n        : mobileScrollConfig.scrollPerCard;\n      const baseScroll = isDesktop\n        ? desktopScrollConfig.baseScroll\n        : mobileScrollConfig.baseScroll;\n      const endScroll = isDesktop\n        ? desktopScrollConfig.endScroll\n        : mobileScrollConfig.endScroll;\n\n      setEndScrollVh(endScroll);\n      const totalScroll = baseScroll + cards.length * scrollPerCard + endScroll;\n      setScrollHeight(`${totalScroll}vh`);\n    };\n\n    calculateScrollHeight();\n    window.addEventListener(\"resize\", calculateScrollHeight);\n    return () => window.removeEventListener(\"resize\", calculateScrollHeight);\n  }, [cards.length, desktopScrollConfig, mobileScrollConfig]);\n\n  // biome-ignore lint/correctness/useExhaustiveDependencies: false positive\n  useEffect(() => {\n    const updateRect = () => {\n      if (containerRef.current) {\n        const boundingRect = containerRef.current.getBoundingClientRect();\n        const height = containerRef.current.scrollHeight;\n        setRect({\n          top: boundingRect.top + window.scrollY,\n          height: height,\n        });\n\n        // Calculate background height based on container height and parallax ratio\n        const extraHeight = height * validatedParallaxRatio;\n        const totalHeight = window.innerHeight + extraHeight;\n        setBackgroundHeight(`${totalHeight}px`);\n      }\n    };\n\n    updateRect();\n    window.addEventListener(\"resize\", updateRect);\n    return () => window.removeEventListener(\"resize\", updateRect);\n  }, [scrollHeight]); // Re-run when scrollHeight changes\n\n  useScroll(\n    ({ scroll }) => {\n      const windowHeight = window.innerHeight;\n      const start = rect.top - windowHeight * 2;\n      // Subtract endScroll from height so progress reaches 100% before the end padding\n      const endScrollPixels = (endScrollVh / 100) * windowHeight;\n      const end = rect.top + rect.height - windowHeight - endScrollPixels;\n\n      const progress = clamp(0, mapRange(start, end, scroll, 0, 1), 1);\n\n      if (cardsContainerRef.current) {\n        const clampedProgress = clamp(\n          0,\n          mapRange(rect.top, end, scroll, 0, 1),\n          1,\n        );\n        cardsContainerRef.current.style.setProperty(\n          \"--progress\",\n          clampedProgress.toString(),\n        );\n      }\n\n      if (backgroundRef.current && containerRef.current) {\n        const containerTop = rect.top;\n        const relativeScroll = scroll - containerTop;\n        const parallaxOffset = relativeScroll * -validatedParallaxRatio;\n        backgroundRef.current.style.transform = `translateY(${parallaxOffset}px)`;\n      }\n\n      const step = Math.floor(progress * cards.length);\n      setCurrent(step);\n    },\n    [rect, cards.length],\n  );\n\n  return (\n    <div\n      ref={containerRef}\n      className={cn(\"relative\", className, containerClassName)}\n      style={{ minHeight: scrollHeight }}\n    >\n      <div className=\"sticky top-0 h-screen overflow-hidden p-4 md:p-8\">\n        {/* Parallax Background */}\n        {showBackground && (\n          <div\n            ref={backgroundRef}\n            className={cn(\n              \"pointer-events-none absolute inset-0 bg-position-[center_center] will-change-transform\",\n              getBackgroundPattern(),\n            )}\n            style={{ height: backgroundHeight }}\n          >\n            <div className=\"-top-8 absolute right-0 left-0 h-[15vh] w-full bg-linear-to-b from-primary-foreground to-transparent\" />\n            <div className=\"absolute right-0 bottom-0 left-0 h-[30vh] w-full bg-linear-to-t from-primary-foreground to-transparent\" />\n          </div>\n        )}\n        <div className=\"relative h-full\">\n          {header && (\n            <aside className=\"mb-8 text-right md:absolute md:top-0 md:right-0\">\n              <h2 className=\"font-bold text-xl sm:text-4xl xl:text-5xl 2xl:text-6xl\">\n                {header.title}\n                <br />\n                <span className=\"text-foreground/70\">{header.subtitle}</span>\n              </h2>\n            </aside>\n          )}\n\n          <div\n            ref={cardsContainerRef}\n            className=\"relative h-full pt-24 md:pt-0\"\n          >\n            {cards.map((card, index) => (\n              <SingleCard\n                // biome-ignore lint/suspicious/noArrayIndexKey: false positive\n                key={index}\n                index={index}\n                title={card.title}\n                description={card.description}\n                number={card.number || index + 1}\n                current={index <= current - 1}\n                totalCards={cards.length}\n                desktopDimensions={desktopDimensions}\n                mobileDimensions={mobileDimensions}\n                transitionDuration={transitionDuration}\n                cardClassName={cardClassName}\n                cardStyle={cardStyle}\n              />\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n}\n\ninterface SingleCardProps {\n  title?: string;\n  description?: string | React.ReactNode;\n  number: number;\n  index: number;\n  current: boolean;\n  totalCards: number;\n  desktopDimensions: CardDimensions;\n  mobileDimensions: CardDimensions;\n  transitionDuration: number;\n  cardClassName?: string;\n  cardStyle: \"default\" | \"lenis\";\n}\n\nfunction SingleCard({\n  title,\n  description,\n  index,\n  current,\n  totalCards,\n  desktopDimensions,\n  mobileDimensions,\n  transitionDuration,\n  cardClassName,\n  cardStyle,\n}: SingleCardProps) {\n  const [position, setPosition] = useState({ top: \"0px\", left: \"0\" });\n  const [isMounted, setIsMounted] = useState(false);\n  const [isDesktop, setIsDesktop] = useState(false);\n\n  useEffect(() => {\n    setIsMounted(true);\n    setIsDesktop(window.innerWidth >= 768);\n  }, []);\n\n  useEffect(() => {\n    const handleResize = () => {\n      setIsDesktop(window.innerWidth >= 768);\n    };\n    window.addEventListener(\"resize\", handleResize);\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  useEffect(() => {\n    if (!isMounted) return;\n\n    const getCardPosition = () => {\n      // Calculate available space (screen height/width minus card size and padding)\n      const cardHeight = isDesktop\n        ? desktopDimensions.height\n        : mobileDimensions.height;\n      const cardWidth = isDesktop\n        ? desktopDimensions.width\n        : mobileDimensions.width;\n      const padding = isDesktop ? 64 : 32; // Account for container padding\n\n      // On mobile, use a percentage-based approach to distribute cards more evenly\n      let availableHeight = isDesktop\n        ? window.innerHeight - cardHeight - padding * 2\n        : window.innerHeight * 0.4;\n      let availableWidth = window.innerWidth - cardWidth - padding * 2;\n\n      // Auto-adjust if cards don't fit: ensure minimum spacing\n      if (availableHeight < 0) {\n        availableHeight = Math.max(50, window.innerHeight * 0.3);\n      }\n      if (availableWidth < 0) {\n        availableWidth = Math.max(20, window.innerWidth * 0.1);\n      }\n\n      // Calculate consistent diagonal spacing for bottom-right direction\n      const minSpacing = isDesktop ? 40 : 20;\n      let spacingTop = totalCards > 1 ? availableHeight / (totalCards - 1) : 0;\n      let spacingLeft = totalCards > 1 ? availableWidth / (totalCards - 1) : 0;\n\n      // Ensure minimum spacing between cards\n      spacingTop = Math.max(minSpacing, spacingTop);\n      spacingLeft = Math.max(minSpacing, spacingLeft);\n\n      // For consistent diagonal movement, don't clamp to available space\n      // Allow cards to continue moving in bottom-right direction\n      return {\n        top: `${index * spacingTop}px`,\n        left: isDesktop ? `${index * spacingLeft}px` : \"0\",\n      };\n    };\n\n    const updatePosition = () => {\n      setPosition(getCardPosition());\n    };\n\n    updatePosition();\n    window.addEventListener(\"resize\", updatePosition);\n    return () => window.removeEventListener(\"resize\", updatePosition);\n  }, [\n    isMounted,\n    index,\n    totalCards,\n    desktopDimensions,\n    mobileDimensions,\n    isDesktop,\n  ]);\n\n  return (\n    <div\n      className={cn(\n        \"-translate-x-1/2 absolute left-1/2 backdrop-blur-sm transition-all ease-out md:left-0 md:translate-x-0\",\n        current ? \"opacity-100\" : \"opacity-0\",\n      )}\n      style={{\n        top: current ? position.top : \"0px\",\n        left: isMounted && isDesktop ? position.left : undefined,\n        transitionDuration: `${transitionDuration}ms`,\n      }}\n    >\n      <Card\n        className={cn(\n          \"relative overflow-hidden bg-background/30\",\n          cardClassName,\n        )}\n        style={{\n          width: `${isDesktop ? desktopDimensions.width : mobileDimensions.width}px`,\n          height: `${isDesktop ? desktopDimensions.height : mobileDimensions.height}px`,\n        }}\n      >\n        <CardHeader className=\"flex h-full flex-col justify-between p-4 md:p-6\">\n          {cardStyle === \"default\" ? (\n            <CardTitle className=\"font-mono font-semibold text-2xl text-main/50 md:text-5xl\">\n              {title}\n            </CardTitle>\n          ) : (\n            <CardTitle className=\"font-mono font-semibold text-3xl text-main/50 md:text-7xl\">\n              {(index + 1).toString().padStart(2, \"0\")}\n            </CardTitle>\n          )}\n          <CardDescription className=\"overflow-y-auto text-sm md:text-xl\">\n            {description}\n          </CardDescription>\n        </CardHeader>\n      </Card>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "labs-registry/components-v1/lib/use-scroll.ts",
      "content": "import { useEffect } from \"react\";\n\nexport function useScroll(\n  callback: (data: {\n    scroll: number;\n    limit: number;\n    velocity: number;\n    direction: number;\n    progress: number;\n  }) => void,\n  deps: React.DependencyList = [],\n) {\n  useEffect(() => {\n    const handleScroll = () => {\n      const scroll = window.scrollY;\n      const limit = document.documentElement.scrollHeight - window.innerHeight;\n      const progress = limit > 0 ? scroll / limit : 0;\n\n      callback({\n        scroll,\n        limit,\n        velocity: 0, // simplified version\n        direction: 0, // simplified version\n        progress,\n      });\n    };\n\n    window.addEventListener(\"scroll\", handleScroll);\n    handleScroll(); // Initial call\n\n    return () => {\n      window.removeEventListener(\"scroll\", handleScroll);\n    };\n  }, [callback, ...deps]);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "labs-registry/components-v1/lib/maths.ts",
      "content": "export function clamp(min: number, input: number, max: number): number {\n  return Math.max(min, Math.min(input, max));\n}\n\nexport function mapRange(\n  in_min: number,\n  in_max: number,\n  input: number,\n  out_min: number,\n  out_max: number,\n): number {\n  return ((input - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;\n}\n\nexport function lerp(x: number, y: number, t: number): number {\n  return (1 - t) * x + t * y;\n}\n\nexport function truncate(value: number, decimals: number): number {\n  return parseFloat(value.toFixed(decimals));\n}\n",
      "type": "registry:lib"
    }
  ]
}