{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "card-overlap-scroll",
  "type": "registry:component",
  "description": "basically a card but it",
  "files": [
    {
      "path": "labs-registry/components-v1/card-overlap-scroll.tsx",
      "content": "\"use client\";\r\n\r\nimport { useRef, useState, useEffect, useMemo, useCallback } from \"react\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport {\r\n  Card,\r\n  CardHeader,\r\n  CardTitle,\r\n  CardDescription,\r\n} from \"@/components/ui/card\";\r\nimport { useScroll } from \"@/labs-registry/components-v1/functions/hooks/use-scroll\";\r\nimport {\r\n  clamp,\r\n  mapRange,\r\n} from \"@/labs-registry/components-v1/functions/lib/maths\";\r\n\r\nexport interface OverlapCard {\r\n  title?: string;\r\n  description: string | React.ReactNode;\r\n  number?: number;\r\n}\r\n\r\nexport interface OverlapCardsProps {\r\n  cards: OverlapCard[];\r\n  className?: string;\r\n  // Header customization\r\n  header?: {\r\n    title: string;\r\n    subtitle: string;\r\n  };\r\n  // Scroll behavior\r\n  desktopScroll?: Partial<ScrollBehavior>;\r\n  mobileScroll?: Partial<ScrollBehavior>;\r\n  // Visual effects\r\n  parallaxRatio?: number;\r\n  showBackground?: boolean;\r\n  backgroundPattern?: \"grid\" | \"dots\" | \"none\";\r\n  // Card appearance\r\n  desktopCardDimensions?: Partial<CardDimensions>;\r\n  mobileCardDimensions?: Partial<CardDimensions>;\r\n  transitionDuration?: number;\r\n  cardClassName?: string;\r\n  cardStyle?: \"default\" | \"lenis\";\r\n  // Container styling\r\n  containerClassName?: string;\r\n}\r\n\r\nexport interface CardDimensions {\r\n  width: number;\r\n  height: number;\r\n}\r\n\r\nexport interface ScrollBehavior {\r\n  scrollPerCard: number;\r\n  baseScroll: number;\r\n  endScroll: number;\r\n}\r\n\r\nexport function OverlapCards({\r\n  cards,\r\n  className,\r\n  header,\r\n  desktopScroll = {},\r\n  mobileScroll = {},\r\n  parallaxRatio = 0.1,\r\n  showBackground = true,\r\n  backgroundPattern = \"grid\",\r\n  desktopCardDimensions = {},\r\n  mobileCardDimensions = {},\r\n  transitionDuration = 1000,\r\n  cardClassName,\r\n  cardStyle = \"lenis\",\r\n  containerClassName,\r\n}: OverlapCardsProps) {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const cardsContainerRef = useRef<HTMLDivElement>(null);\r\n  const backgroundRef = useRef<HTMLDivElement>(null);\r\n  const [rect, setRect] = useState({ top: 0, height: 0 });\r\n  const [current, setCurrent] = useState(0);\r\n  const [backgroundHeight, setBackgroundHeight] = useState(\"200vh\");\r\n  const [scrollHeight, setScrollHeight] = useState(\"100vh\");\r\n  const [endScrollVh, setEndScrollVh] = useState(0);\r\n\r\n  // Validate parallax ratio (between 0 and 1)\r\n  const validatedParallaxRatio = Math.max(0, Math.min(1, parallaxRatio));\r\n\r\n  // Default values for scroll behavior\r\n  const defaultDesktopScroll: ScrollBehavior = {\r\n    scrollPerCard: 60,\r\n    baseScroll: 80,\r\n    endScroll: 100,\r\n  };\r\n  const defaultMobileScroll: ScrollBehavior = {\r\n    scrollPerCard: 120,\r\n    baseScroll: 200,\r\n    endScroll: 150,\r\n  };\r\n\r\n  // Default values for card dimensions\r\n  const defaultDesktopDimensions: CardDimensions = { width: 480, height: 320 };\r\n  const defaultMobileDimensions: CardDimensions = { width: 280, height: 200 };\r\n\r\n  // Validation helpers\r\n  const validateScrollBehavior = useCallback(\r\n    (\r\n      config: Partial<ScrollBehavior>,\r\n      defaults: ScrollBehavior,\r\n    ): ScrollBehavior => {\r\n      return {\r\n        scrollPerCard: Math.max(\r\n          10,\r\n          config.scrollPerCard ?? defaults.scrollPerCard,\r\n        ),\r\n        baseScroll: Math.max(0, config.baseScroll ?? defaults.baseScroll),\r\n        endScroll: Math.max(0, config.endScroll ?? defaults.endScroll),\r\n      };\r\n    },\r\n    [],\r\n  );\r\n\r\n  const validateDimensions = useCallback(\r\n    (\r\n      dimensions: Partial<CardDimensions>,\r\n      defaults: CardDimensions,\r\n      isDesktop: boolean,\r\n    ): CardDimensions => {\r\n      const minWidth = isDesktop ? 200 : 150;\r\n      const minHeight = isDesktop ? 150 : 100;\r\n      const maxWidth = isDesktop\r\n        ? typeof window !== \"undefined\"\r\n          ? window.innerWidth * 0.8\r\n          : 800\r\n        : 400;\r\n      const maxHeight = isDesktop\r\n        ? typeof window !== \"undefined\"\r\n          ? window.innerHeight * 0.6\r\n          : 600\r\n        : 300;\r\n\r\n      return {\r\n        width: Math.min(\r\n          maxWidth,\r\n          Math.max(minWidth, dimensions.width ?? defaults.width),\r\n        ),\r\n        height: Math.min(\r\n          maxHeight,\r\n          Math.max(minHeight, dimensions.height ?? defaults.height),\r\n        ),\r\n      };\r\n    },\r\n    [],\r\n  );\r\n\r\n  const desktopScrollConfig = useMemo(\r\n    () => validateScrollBehavior(desktopScroll, defaultDesktopScroll),\r\n    [desktopScroll, validateScrollBehavior],\r\n  );\r\n  const mobileScrollConfig = useMemo(\r\n    () => validateScrollBehavior(mobileScroll, defaultMobileScroll),\r\n    [mobileScroll, validateScrollBehavior],\r\n  );\r\n  const desktopDimensions = useMemo(\r\n    () =>\r\n      validateDimensions(desktopCardDimensions, defaultDesktopDimensions, true),\r\n    [desktopCardDimensions, validateDimensions],\r\n  );\r\n  const mobileDimensions = useMemo(\r\n    () =>\r\n      validateDimensions(mobileCardDimensions, defaultMobileDimensions, false),\r\n    [mobileCardDimensions, validateDimensions],\r\n  );\r\n\r\n  // Get background pattern classes\r\n  const getBackgroundPattern = () => {\r\n    if (!showBackground || backgroundPattern === \"none\") return \"\";\r\n    if (backgroundPattern === \"dots\") {\r\n      return \"bg-[radial-gradient(#80808033_1px,transparent_1px)] bg-size-[20px_20px]\";\r\n    }\r\n    return \"bg-[linear-gradient(to_right,#80808033_1px,transparent_1px),linear-gradient(to_bottom,#80808033_1px,transparent_1px)] bg-size-[70px_70px]\";\r\n  };\r\n\r\n  // Calculate scroll height based on cards count and device\r\n  useEffect(() => {\r\n    const calculateScrollHeight = () => {\r\n      const isDesktop = window.innerWidth >= 768;\r\n      // Use custom scroll values or defaults\r\n      const scrollPerCard = isDesktop\r\n        ? desktopScrollConfig.scrollPerCard\r\n        : mobileScrollConfig.scrollPerCard;\r\n      const baseScroll = isDesktop\r\n        ? desktopScrollConfig.baseScroll\r\n        : mobileScrollConfig.baseScroll;\r\n      const endScroll = isDesktop\r\n        ? desktopScrollConfig.endScroll\r\n        : mobileScrollConfig.endScroll;\r\n\r\n      setEndScrollVh(endScroll);\r\n      const totalScroll = baseScroll + cards.length * scrollPerCard + endScroll;\r\n      setScrollHeight(`${totalScroll}vh`);\r\n    };\r\n\r\n    calculateScrollHeight();\r\n    window.addEventListener(\"resize\", calculateScrollHeight);\r\n    return () => window.removeEventListener(\"resize\", calculateScrollHeight);\r\n  }, [cards.length, desktopScrollConfig, mobileScrollConfig]);\r\n\r\n  // biome-ignore lint/correctness/useExhaustiveDependencies: false positive\r\n  useEffect(() => {\r\n    const updateRect = () => {\r\n      if (containerRef.current) {\r\n        const boundingRect = containerRef.current.getBoundingClientRect();\r\n        const height = containerRef.current.scrollHeight;\r\n        setRect({\r\n          top: boundingRect.top + window.scrollY,\r\n          height: height,\r\n        });\r\n\r\n        // Calculate background height based on container height and parallax ratio\r\n        const extraHeight = height * validatedParallaxRatio;\r\n        const totalHeight = window.innerHeight + extraHeight;\r\n        setBackgroundHeight(`${totalHeight}px`);\r\n      }\r\n    };\r\n\r\n    updateRect();\r\n    window.addEventListener(\"resize\", updateRect);\r\n    return () => window.removeEventListener(\"resize\", updateRect);\r\n  }, [scrollHeight]); // Re-run when scrollHeight changes\r\n\r\n  useScroll(\r\n    ({ scroll }) => {\r\n      const windowHeight = window.innerHeight;\r\n      const start = rect.top - windowHeight * 2;\r\n      // Subtract endScroll from height so progress reaches 100% before the end padding\r\n      const endScrollPixels = (endScrollVh / 100) * windowHeight;\r\n      const end = rect.top + rect.height - windowHeight - endScrollPixels;\r\n\r\n      const progress = clamp(0, mapRange(start, end, scroll, 0, 1), 1);\r\n\r\n      if (cardsContainerRef.current) {\r\n        const clampedProgress = clamp(\r\n          0,\r\n          mapRange(rect.top, end, scroll, 0, 1),\r\n          1,\r\n        );\r\n        cardsContainerRef.current.style.setProperty(\r\n          \"--progress\",\r\n          clampedProgress.toString(),\r\n        );\r\n      }\r\n\r\n      if (backgroundRef.current && containerRef.current) {\r\n        const containerTop = rect.top;\r\n        const relativeScroll = scroll - containerTop;\r\n        const parallaxOffset = relativeScroll * -validatedParallaxRatio;\r\n        backgroundRef.current.style.transform = `translateY(${parallaxOffset}px)`;\r\n      }\r\n\r\n      const step = Math.floor(progress * cards.length);\r\n      setCurrent(step);\r\n    },\r\n    [rect, cards.length],\r\n  );\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      className={cn(\"relative\", className, containerClassName)}\r\n      style={{ minHeight: scrollHeight }}\r\n    >\r\n      <div className=\"sticky top-0 h-screen overflow-hidden p-4 md:p-8\">\r\n        {/* Parallax Background */}\r\n        {showBackground && (\r\n          <div\r\n            ref={backgroundRef}\r\n            className={cn(\r\n              \"pointer-events-none absolute inset-0 bg-position-[center_center] will-change-transform\",\r\n              getBackgroundPattern(),\r\n            )}\r\n            style={{ height: backgroundHeight }}\r\n          >\r\n            <div className=\"-top-8 absolute right-0 left-0 h-[15vh] w-full bg-linear-to-b from-primary-foreground to-transparent\" />\r\n            <div className=\"absolute right-0 bottom-0 left-0 h-[30vh] w-full bg-linear-to-t from-primary-foreground to-transparent\" />\r\n          </div>\r\n        )}\r\n        <div className=\"relative h-full\">\r\n          {header && (\r\n            <aside className=\"mb-8 text-right md:absolute md:top-0 md:right-0\">\r\n              <h2 className=\"font-bold text-xl sm:text-4xl xl:text-5xl 2xl:text-6xl\">\r\n                {header.title}\r\n                <br />\r\n                <span className=\"text-foreground/70\">{header.subtitle}</span>\r\n              </h2>\r\n            </aside>\r\n          )}\r\n\r\n          <div\r\n            ref={cardsContainerRef}\r\n            className=\"relative h-full pt-24 md:pt-0\"\r\n          >\r\n            {cards.map((card, index) => (\r\n              <SingleCard\r\n                // biome-ignore lint/suspicious/noArrayIndexKey: false positive\r\n                key={index}\r\n                index={index}\r\n                title={card.title}\r\n                description={card.description}\r\n                number={card.number || index + 1}\r\n                current={index <= current - 1}\r\n                totalCards={cards.length}\r\n                desktopDimensions={desktopDimensions}\r\n                mobileDimensions={mobileDimensions}\r\n                transitionDuration={transitionDuration}\r\n                cardClassName={cardClassName}\r\n                cardStyle={cardStyle}\r\n              />\r\n            ))}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\ninterface SingleCardProps {\r\n  title?: string;\r\n  description?: string | React.ReactNode;\r\n  number: number;\r\n  index: number;\r\n  current: boolean;\r\n  totalCards: number;\r\n  desktopDimensions: CardDimensions;\r\n  mobileDimensions: CardDimensions;\r\n  transitionDuration: number;\r\n  cardClassName?: string;\r\n  cardStyle: \"default\" | \"lenis\";\r\n}\r\n\r\nfunction SingleCard({\r\n  title,\r\n  description,\r\n  index,\r\n  current,\r\n  totalCards,\r\n  desktopDimensions,\r\n  mobileDimensions,\r\n  transitionDuration,\r\n  cardClassName,\r\n  cardStyle,\r\n}: SingleCardProps) {\r\n  const [position, setPosition] = useState({ top: \"0px\", left: \"0\" });\r\n  const [isMounted, setIsMounted] = useState(false);\r\n  const [isDesktop, setIsDesktop] = useState(false);\r\n\r\n  useEffect(() => {\r\n    setIsMounted(true);\r\n    setIsDesktop(window.innerWidth >= 768);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const handleResize = () => {\r\n      setIsDesktop(window.innerWidth >= 768);\r\n    };\r\n    window.addEventListener(\"resize\", handleResize);\r\n    return () => window.removeEventListener(\"resize\", handleResize);\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (!isMounted) return;\r\n\r\n    const getCardPosition = () => {\r\n      // Calculate available space (screen height/width minus card size and padding)\r\n      const cardHeight = isDesktop\r\n        ? desktopDimensions.height\r\n        : mobileDimensions.height;\r\n      const cardWidth = isDesktop\r\n        ? desktopDimensions.width\r\n        : mobileDimensions.width;\r\n      const padding = isDesktop ? 64 : 32; // Account for container padding\r\n\r\n      // On mobile, use a percentage-based approach to distribute cards more evenly\r\n      let availableHeight = isDesktop\r\n        ? window.innerHeight - cardHeight - padding * 2\r\n        : window.innerHeight * 0.4;\r\n      let availableWidth = window.innerWidth - cardWidth - padding * 2;\r\n\r\n      // Auto-adjust if cards don't fit: ensure minimum spacing\r\n      if (availableHeight < 0) {\r\n        availableHeight = Math.max(50, window.innerHeight * 0.3);\r\n      }\r\n      if (availableWidth < 0) {\r\n        availableWidth = Math.max(20, window.innerWidth * 0.1);\r\n      }\r\n\r\n      // Calculate consistent diagonal spacing for bottom-right direction\r\n      const minSpacing = isDesktop ? 40 : 20;\r\n      let spacingTop = totalCards > 1 ? availableHeight / (totalCards - 1) : 0;\r\n      let spacingLeft = totalCards > 1 ? availableWidth / (totalCards - 1) : 0;\r\n\r\n      // Ensure minimum spacing between cards\r\n      spacingTop = Math.max(minSpacing, spacingTop);\r\n      spacingLeft = Math.max(minSpacing, spacingLeft);\r\n\r\n      // For consistent diagonal movement, don't clamp to available space\r\n      // Allow cards to continue moving in bottom-right direction\r\n      return {\r\n        top: `${index * spacingTop}px`,\r\n        left: isDesktop ? `${index * spacingLeft}px` : \"0\",\r\n      };\r\n    };\r\n\r\n    const updatePosition = () => {\r\n      setPosition(getCardPosition());\r\n    };\r\n\r\n    updatePosition();\r\n    window.addEventListener(\"resize\", updatePosition);\r\n    return () => window.removeEventListener(\"resize\", updatePosition);\r\n  }, [\r\n    isMounted,\r\n    index,\r\n    totalCards,\r\n    desktopDimensions,\r\n    mobileDimensions,\r\n    isDesktop,\r\n  ]);\r\n\r\n  return (\r\n    <div\r\n      className={cn(\r\n        \"-translate-x-1/2 absolute left-1/2 backdrop-blur-sm transition-all ease-out md:left-0 md:translate-x-0\",\r\n        current ? \"opacity-100\" : \"opacity-0\",\r\n      )}\r\n      style={{\r\n        top: current ? position.top : \"0px\",\r\n        left: isMounted && isDesktop ? position.left : undefined,\r\n        transitionDuration: `${transitionDuration}ms`,\r\n      }}\r\n    >\r\n      <Card\r\n        className={cn(\r\n          \"relative overflow-hidden bg-background/30\",\r\n          cardClassName,\r\n        )}\r\n        style={{\r\n          width: `${isDesktop ? desktopDimensions.width : mobileDimensions.width}px`,\r\n          height: `${isDesktop ? desktopDimensions.height : mobileDimensions.height}px`,\r\n        }}\r\n      >\r\n        <CardHeader className=\"flex h-full flex-col justify-between p-4 md:p-6\">\r\n          {cardStyle === \"default\" ? (\r\n            <CardTitle className=\"font-mono font-semibold text-2xl text-main/50 md:text-5xl\">\r\n              {title}\r\n            </CardTitle>\r\n          ) : (\r\n            <CardTitle className=\"font-mono font-semibold text-3xl text-main/50 md:text-7xl\">\r\n              {(index + 1).toString().padStart(2, \"0\")}\r\n            </CardTitle>\r\n          )}\r\n          <CardDescription className=\"overflow-y-auto text-sm md:text-xl\">\r\n            {description}\r\n          </CardDescription>\r\n        </CardHeader>\r\n      </Card>\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "labs-registry/components-v1/lib/use-scroll.ts",
      "content": "import { useEffect } from \"react\";\r\n\r\nexport function useScroll(\r\n  callback: (data: {\r\n    scroll: number;\r\n    limit: number;\r\n    velocity: number;\r\n    direction: number;\r\n    progress: number;\r\n  }) => void,\r\n  deps: React.DependencyList = [],\r\n) {\r\n  useEffect(() => {\r\n    const handleScroll = () => {\r\n      const scroll = window.scrollY;\r\n      const limit = document.documentElement.scrollHeight - window.innerHeight;\r\n      const progress = limit > 0 ? scroll / limit : 0;\r\n\r\n      callback({\r\n        scroll,\r\n        limit,\r\n        velocity: 0, // simplified version\r\n        direction: 0, // simplified version\r\n        progress,\r\n      });\r\n    };\r\n\r\n    window.addEventListener(\"scroll\", handleScroll);\r\n    handleScroll(); // Initial call\r\n\r\n    return () => {\r\n      window.removeEventListener(\"scroll\", handleScroll);\r\n    };\r\n  }, [callback, ...deps]);\r\n}\r\n",
      "type": "registry:lib"
    },
    {
      "path": "labs-registry/components-v1/lib/maths.ts",
      "content": "export function clamp(min: number, input: number, max: number): number {\r\n  return Math.max(min, Math.min(input, max));\r\n}\r\n\r\nexport function mapRange(\r\n  in_min: number,\r\n  in_max: number,\r\n  input: number,\r\n  out_min: number,\r\n  out_max: number,\r\n): number {\r\n  return ((input - in_min) * (out_max - out_min)) / (in_max - in_min) + out_min;\r\n}\r\n\r\nexport function lerp(x: number, y: number, t: number): number {\r\n  return (1 - t) * x + t * y;\r\n}\r\n\r\nexport function truncate(value: number, decimals: number): number {\r\n  return parseFloat(value.toFixed(decimals));\r\n}\r\n",
      "type": "registry:lib"
    }
  ]
}